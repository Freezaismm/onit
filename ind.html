<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nadine's Cyber Connect</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #050a14;
            --panel-bg: #0f172a;
            --neon-pink: #ff0055;
            --neon-cyan: #00f2ff;
            --neon-purple: #bc13fe;
            --text-glow: 0 0 10px rgba(0, 242, 255, 0.7);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }

        body {
            margin: 0;
            background-color: var(--bg-dark);
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* --- BACKGROUND EFFECTS --- */
        .grid-bg {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(0, 242, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 0, 85, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
            perspective: 500px;
            transform: scale(1.2);
            z-index: -1;
            opacity: 0.5;
        }

        .vignette {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, #000 150%);
            pointer-events: none;
            z-index: 100;
        }

        /* --- LAYOUT CONTAINER --- */
        .game-container {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* --- SCREENS --- */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: rgba(5, 10, 20, 0.95);
            transition: opacity 0.5s, transform 0.5s;
            z-index: 10;
            padding: 20px;
        }
        .screen.hidden { opacity: 0; pointer-events: none; transform: scale(1.1); }

        /* --- PHOTO FRAMES --- */
        .holo-frame {
            width: 160px; height: 160px;
            border: 2px solid var(--neon-cyan);
            padding: 5px;
            position: relative;
            margin-bottom: 20px;
            box-shadow: 0 0 20px var(--neon-cyan), inset 0 0 20px var(--neon-cyan);
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }
        .holo-frame img {
            width: 100%; height: 100%;
            object-fit: cover;
            filter: contrast(1.2) brightness(1.1);
        }

        /* --- TYPOGRAPHY --- */
        h1 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255,255,255,0.2);
            text-align: center;
        }

        p { color: #ccc; font-size: 0.8rem; text-align: center; max-width: 300px; letter-spacing: 1px; }

        /* --- BUTTONS --- */
        .btn {
            background: transparent;
            color: var(--neon-cyan);
            border: 2px solid var(--neon-cyan);
            padding: 12px 30px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 10px var(--neon-cyan);
            transition: all 0.2s;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
        .btn:active { background: var(--neon-cyan); color: #000; transform: scale(0.95); }
        .btn-shuffle {
            position: absolute; bottom: 30px;
            font-size: 0.8rem; padding: 10px 20px;
            border-color: var(--neon-pink); color: var(--neon-pink);
            box-shadow: 0 0 10px var(--neon-pink);
        }

        /* --- GAME BOARD --- */
        #game-ui {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 10px;
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }

        .header-bar {
            width: 100%; display: flex; justify-content: space-between;
            padding: 0 10px 10px 10px; margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            width: 100%;
            max-width: 380px;
            position: relative;
        }

        .tile {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 1px solid #334155;
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.8rem;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            position: relative;
        }
        
        .tile.selected {
            background: rgba(0, 242, 255, 0.2);
            border: 2px solid var(--neon-cyan);
            box-shadow: 0 0 15px var(--neon-cyan);
            transform: scale(1.05);
            z-index: 2;
        }
        
        .tile.matched {
            visibility: hidden;
            pointer-events: none;
        }

        /* Canvas for drawing lines */
        #line-canvas {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
            z-index: 5;
        }

        /* --- WIN LONG TEXT --- */
        .terminal-text {
            width: 100%;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--neon-pink);
            padding: 15px;
            height: 250px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            color: #ffb6c1;
            margin-bottom: 20px;
            border-left: 4px solid var(--neon-pink);
            text-shadow: 0 0 2px var(--neon-pink);
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: var(--neon-cyan); border-radius: 3px; }

    </style>
</head>
<body>

    <div class="grid-bg"></div>
    <div class="vignette"></div>

    <div class="game-container">
        
        <div id="start-screen" class="screen">
            <div class="holo-frame">
                <img src="https://img.sanishtech.com/u/8becae61ad0abf83706d682810587469.png" alt="Nadine Start">
            </div>
            <h1>NADINE'S<br>CONNECT</h1>
            <p>for my honey<br>Nadine Syakira</p>
            <button class="btn" onclick="startGame()">MAINKAN</button>
        </div>

        <div id="game-screen" class="screen hidden" style="background: transparent;">
            <div id="game-ui">
                <div class="header-bar">
                    <span style="color:var(--neon-cyan)">LINK: <b id="score">0</b>/15</span>
                    <span style="color:var(--neon-pink)">TIME: <b id="timer">00:00</b></span>
                </div>
                
                <div class="grid-container" id="grid">
                    <canvas id="line-canvas"></canvas>
                    </div>
            </div>
            
            <button class="btn btn-shuffle" onclick="shuffleBoard()">SHUFFLE BOARD</button>
        </div>

        <div id="win-screen" class="screen hidden">
            <h1 style="font-size: 2rem;">SELAMAT<br>SAYANG</h1>
            
            <div class="holo-frame" style="border-color: var(--neon-pink); width: 100px; height: 100px;">
                <img src="https://img.sanishtech.com/u/56a900f531ac76ba5605988ee993f379.png" alt="Nadine Win">
            </div>

            <div class="terminal-text" id="typewriter"></div>
            
            <button class="btn" onclick="location.reload()">RECONNECT</button>
        </div>

    </div>

    <script>
        // --- KONFIGURASI PESAN ---
        const loveLetter = `HAAII HAAII NADINEE SYAKIRAAA PRETTYYYY

Akhirnyaaa main game lagi yakkk, setelah kemarin liburrr wkwkwkwkwkwkwk, yaa ak kemarin ga bikin gamee karenaa kita sehariann bertemu dan besok paginyaa kitaa langsung bertemu lagii wkwkwkw, jadii paling gamenya bakalan nganggu dan mending main minikreff wkwkwkw dan alhamdulillah kita bisa seharian main minikreff yaakk.. yaa game ini ku bikin jam 3 pagii jadinya mungkin ga maksimalblongteksnyaaa bcs ngantukkkss wkkwwkkwkwk

Okeyydee pertama tamaa aku akan longteks mulai jumat dehhh, timakasii banyak banyakk yaa waktu hari jumat udah nemenin aku sehariann, di sekolah kamu nemenin akkk, yaa walaupun kamu terkena sedikit masalah, tapi kamu tetep percaya sama ak kann.. tetep jadi anak yang kuatt yaa nadineee.. ini cuma cobaan sementaraa kokk, enggaaa bakal teruss terjadii.. bakal jadi berkahmu tersendirii ituu nantii nadd.. jadii yaa santaii ajaa yaaa, apapun yang terjadii ituu yang terbaik buat kamuu.. teruss terimakasihh jugaa yaa udaa ngajakin ps annn, wowww seruu bangett sumpaa daaahhh, akhirnyaaa kita menanatkan a way outtt yaaaa.. seruu pake bangett hehehe timakasiu sudaa memberikan kiss jugak wkwkwkwk.. neekss kita namatin apalagi yaaaa.. terusss akhirnyaaa yaaa kita main minecraft lagiiii, wihh seruu banget lagii kita kalau main minecraft sampee lupa waktu saking serunyaaa wkwkekekwkwk, yakk alhamdulillahh bisaa seseruu ituuu.. nekss adalah hari sabtuuu

nahh di hari sabtu ini seruuu pake bangett deehh pagi pagii udaa ketemu kamuuu, dann melakukan perjalanan yang seruu dan tidaa terdugaa yaaa, waww perjalanan yang sangat melelahkann yaakk akhirnyaa kitaa bisa menamatkann jalan selama 10km anjaayyy kerenn pake bangettt mana seruu bangett, siapaa cobaa yang menyangka bakal ketemu kaka di susukann wkwkwkkwkw, random banget lagiii.. terusss kita sarapann woww sotonyaa enakk pakee bangettt sumpaahhh.. mauu lagii besok kapan kapann yaaa enakk batss enakkkkk.. teruss melanjutkan perjalanan siapaa sangkaa malah ke gap pak yerryy wkwkwkwkk, yaampunn mintaa maaff yaa nadinee heheheee.. dan ternyataa satriaa jugaa melihatt wkwkwkkw.. terusss kerenn bangett dee walaupun di perjalanan banyaka mengeluhh tapi kamu aslinyaa kuat bangett deee bisa sampe rumahh dengann amannn, bahkan masi bisa larii tuu pas terakhirrr.. kerenn bangettt, teruss jugaa saking capenyaa kitaa lupaa kalau beli eskimm wkwkwkkw, jadinyaa malah cair dehhh.. laluuu abis ituu kitaa menguabiskann sisa hari kita dengan bermain minecraftt yaakkk wkwkwkwkwk.. baru kali ini jarang chatannn tapii bermain minecraft bersamaa sehariann dari pagi sampee malemmm terimakasii banyakk yaa nadineee...

maaff yaa kalau gamenyaa telat bangett soalnyaa kemarin capee bangettt wkwkwkkw, dann sibukk kannn.. tapi gapapaa tetep ku usahainn inii mahhh.. selamaatt pagi yaaa sayangg, selamatt beraktivitass yaaaa.. semogaa hari ini di berii kelancarann yaa sayanggg, okeydeee nanti main minecraft lagi yukk.. wkkwkwkw je t'aimeeee bieennn sayangggðŸ©µðŸ’™ðŸ©µðŸ’™ðŸ©µðŸ’™ðŸ©µðŸ’™ðŸ’™ðŸ©µðŸ’™ðŸ©µðŸ’™ðŸ©µðŸ’™ðŸ©µðŸ’™ðŸ©µðŸ’™ðŸ©µðŸ’™ðŸ©µðŸ’™ðŸ©µðŸ’™`;

        // --- GAME CONFIG ---
        const COLS = 6;
        const ROWS = 5; // 30 Tiles total (15 Pairs)
        const ICONS = ["ðŸŒ¹", "ðŸ’Œ", "ðŸ§¸", "ðŸ’", "ðŸ«", "ðŸŽµ", "ðŸŒ™", "ðŸ±", "ðŸ„", "â­", "ðŸ“", "ðŸ’Ž", "ðŸŽ€", "ðŸ¥‘", "ðŸ¦"];
        
        // --- VARIABLES ---
        let board = []; // Array of objects {id, icon, x, y, active}
        let selectedTile = null;
        let matches = 0;
        let startTime;
        let timerInterval;
        let audioCtx = null;
        let canvas, ctx;

        // --- AUDIO ENGINE ---
        function initAudio() {
            if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'select') {
                osc.frequency.setValueAtTime(800, t);
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.1, t);
                osc.start(t); osc.stop(t+0.1);
            } else if (type === 'match') {
                osc.frequency.setValueAtTime(600, t);
                osc.frequency.linearRampToValueAtTime(1200, t+0.1);
                osc.type = 'triangle';
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t+0.3);
                osc.start(t); osc.stop(t+0.3);
            } else if (type === 'error') {
                osc.frequency.setValueAtTime(150, t);
                osc.type = 'sawtooth';
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t+0.2);
                osc.start(t); osc.stop(t+0.2);
            } else if (type === 'win') {
                [440, 554, 659, 880].forEach((f, i) => {
                    let o = audioCtx.createOscillator();
                    let g = audioCtx.createGain();
                    o.connect(g); g.connect(audioCtx.destination);
                    o.frequency.value = f;
                    g.gain.setValueAtTime(0.1, t + i*0.1);
                    g.gain.linearRampToValueAtTime(0, t + i*0.1 + 0.5);
                    o.start(t + i*0.1); o.stop(t + i*0.1 + 0.5);
                });
            }
        }

        // --- GAME LOGIC ---
        function startGame() {
            initAudio();
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');
            
            initBoard();
            startTimer();
            
            // Setup Canvas for lines
            canvas = document.getElementById('line-canvas');
            const gridEl = document.getElementById('grid');
            canvas.width = gridEl.clientWidth;
            canvas.height = gridEl.clientHeight;
            ctx = canvas.getContext('2d');
        }

        function initBoard() {
            // Create pairs
            let tiles = [];
            for (let i = 0; i < (COLS * ROWS) / 2; i++) {
                let icon = ICONS[i % ICONS.length];
                tiles.push(icon, icon);
            }
            // Shuffle
            tiles.sort(() => Math.random() - 0.5);

            // Create Board Grid
            const grid = document.getElementById('grid');
            grid.innerHTML = '<canvas id="line-canvas"></canvas>'; // Keep canvas
            canvas = document.getElementById('line-canvas'); // Re-ref
            ctx = canvas.getContext('2d');
            
            board = [];
            
            tiles.forEach((icon, index) => {
                let x = index % COLS;
                let y = Math.floor(index / COLS);
                
                let tileEl = document.createElement('div');
                tileEl.className = 'tile';
                tileEl.textContent = icon;
                tileEl.dataset.idx = index;
                tileEl.onclick = () => handleTileClick(index);
                
                grid.appendChild(tileEl);
                
                board.push({
                    index: index,
                    icon: icon,
                    x: x, y: y,
                    active: true,
                    el: tileEl
                });
            });

            // Re-setup canvas size after elements added
            setTimeout(() => {
                canvas.width = grid.clientWidth;
                canvas.height = grid.clientHeight;
            }, 100);
        }

        function handleTileClick(idx) {
            const clicked = board[idx];
            if (!clicked.active) return;
            
            if (selectedTile === null) {
                // Select first
                selectedTile = clicked;
                clicked.el.classList.add('selected');
                playSound('select');
            } else if (selectedTile.index === idx) {
                // Deselect
                selectedTile.el.classList.remove('selected');
                selectedTile = null;
            } else {
                // Check Match
                if (selectedTile.icon === clicked.icon) {
                    const path = findPath(selectedTile, clicked);
                    if (path) {
                        // MATCH!
                        playSound('match');
                        drawPath(path);
                        
                        selectedTile.active = false;
                        clicked.active = false;
                        
                        // Delay removing visual
                        setTimeout(() => {
                            selectedTile.el.classList.remove('selected');
                            selectedTile.el.classList.add('matched');
                            clicked.el.classList.add('matched');
                            selectedTile = null;
                            clearCanvas();
                            
                            matches++;
                            document.getElementById('score').textContent = matches;
                            
                            if (matches === (COLS * ROWS) / 2) {
                                winGame();
                            }
                        }, 300);
                        return;
                    }
                }
                
                // No Match or No Path
                playSound('error');
                selectedTile.el.classList.add('shake'); // simple visual cue
                setTimeout(() => selectedTile.el.classList.remove('shake'), 300);
                selectedTile.el.classList.remove('selected');
                selectedTile = null;
            }
        }

        // --- ONET ALGORITHM (SIMPLIFIED PATHFINDING) ---
        function findPath(t1, t2) {
            // 1. Direct Line
            if (checkLine(t1, t2)) return [t1, t2];

            // 2. One Corner
            let c1 = getCorner(t1, t2);
            if (c1 && checkLine(t1, c1) && checkLine(c1, t2)) return [t1, c1, t2];
            
            let c2 = getCorner(t2, t1);
            if (c2 && checkLine(t1, c2) && checkLine(c2, t2)) return [t1, c2, t2];

            // 3. Two Corners (Scan X and Y)
            // Scan Horizontal from t1
            for (let c = 0; c < COLS; c++) {
                let temp = {x: c, y: t1.y};
                if (isEmpty(temp) && checkLine(t1, temp)) {
                    // Check One Corner from temp to t2
                    if (checkLine(temp, {x: t2.x, y: temp.y}) && checkLine({x: t2.x, y: temp.y}, t2)) {
                         // Check emptiness of the corners
                         if(isEmpty({x: t2.x, y: temp.y}) || isSame(t2, {x: t2.x, y: temp.y}))
                            return [t1, temp, {x: t2.x, y: temp.y}, t2];
                    }
                }
            }
            // Scan Vertical from t1
             for (let r = 0; r < ROWS; r++) {
                let temp = {x: t1.x, y: r};
                if (isEmpty(temp) && checkLine(t1, temp)) {
                    if (checkLine(temp, {x: temp.x, y: t2.y}) && checkLine({x: temp.x, y: t2.y}, t2)) {
                        if(isEmpty({x: temp.x, y: t2.y}) || isSame(t2, {x: temp.x, y: t2.y}))
                            return [t1, temp, {x: temp.x, y: t2.y}, t2];
                    }
                }
            }

            return null;
        }

        function checkLine(p1, p2) {
            if (p1.x === p2.x) { // Vertical
                let minY = Math.min(p1.y, p2.y);
                let maxY = Math.max(p1.y, p2.y);
                for (let y = minY + 1; y < maxY; y++) {
                    if (!isEmpty({x: p1.x, y: y})) return false;
                }
                return true;
            } else if (p1.y === p2.y) { // Horizontal
                let minX = Math.min(p1.x, p2.x);
                let maxX = Math.max(p1.x, p2.x);
                for (let x = minX + 1; x < maxX; x++) {
                    if (!isEmpty({x: x, y: p1.y})) return false;
                }
                return true;
            }
            return false;
        }

        function getCorner(t1, t2) {
            let corner = {x: t1.x, y: t2.y};
            if (isEmpty(corner)) return corner;
            return null;
        }

        function isEmpty(p) {
            // Find tile at x,y
            let target = board.find(b => b.x === p.x && b.y === p.y);
            return target && !target.active;
        }
        
        function isSame(p1, p2) { return p1.x === p2.x && p1.y === p2.y; }

        // --- DRAWING & UTILS ---
        function drawPath(points) {
            ctx.strokeStyle = '#00f2ff';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f2ff';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            // Convert grid coords to pixel coords
            // We need to get center of tiles
            const cellW = canvas.width / COLS;
            const cellH = canvas.height / ROWS;

            points.forEach((p, i) => {
                let px = (p.x * cellW) + (cellW / 2);
                let py = (p.y * cellH) + (cellH / 2);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

       function shuffleBoard() {
            // Get active tiles
            let activeTiles = board.filter(t => t.active);
            let icons = activeTiles.map(t => t.icon);
            // Shuffle icons
            icons.sort(() => Math.random() - 0.5);
            // Reassign
            activeTiles.forEach((t, i) => {
                t.icon = icons[i];
                t.el.textContent = icons[i];
                // Deselect
                t.el.classList.remove('selected');
            });
            selectedTile = null;
            playSound('select');
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                let delta = Math.floor((Date.now() - startTime) / 1000);
                let m = Math.floor(delta / 60).toString().padStart(2, '0');
                let s = (delta % 60).toString().padStart(2, '0');
                document.getElementById('timer').textContent = `${m}:${s}`;
            }, 1000);
        }

        function winGame() {
            clearInterval(timerInterval);
            playSound('win');
            setTimeout(() => {
                document.getElementById('game-screen').classList.add('hidden');
                document.getElementById('win-screen').classList.remove('hidden');
                typeText();
            }, 1000);
        }

        function typeText() {
            const el = document.getElementById('typewriter');
            el.textContent = "";
            let i = 0;
            function type() {
                if(i < loveLetter.length) {
                    el.textContent += loveLetter.charAt(i);
                    i++;
                    el.scrollTop = el.scrollHeight;
                    setTimeout(type, 30);
                }
            }
            type();
        }

    </script>
</body>
</html>